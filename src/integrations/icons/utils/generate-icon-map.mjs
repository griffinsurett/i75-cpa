#!/usr/bin/env node
// src/integrations/icons/utils/generate-icon-map.mjs
// Scans the project for icon strings and emits src/integrations/icons/utils/iconMap.generated.ts
// Only the icons actually found are imported (named imports) to keep bundles tiny.

import { promises as fs } from 'node:fs';
import path from 'node:path';
import { pathToFileURL } from 'node:url';

const projectRoot = process.cwd();
// Use the shared toPascalCase from string.ts (compiled to JS via ts-node/tsconfig paths not available here),
// so fall back to a local definition to keep this script runnable in plain Node.
function toPascalCase(str) {
  return str
    .split(/[-_\s]+/)
    .filter(Boolean)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join('');
}
const outputFile = path.join(projectRoot, 'src/integrations/icons/utils/iconMap.generated.ts');

// Load shared icon config (plain ESM for TS/JS compatibility)
const configPath = pathToFileURL(path.join(projectRoot, 'src/integrations/icons/utils/iconConfig.js')).href;
const { ICON_LIBRARIES, SCANNABLE_PREFIXES: SCANNABLE_PREFIXES_ARRAY, normalizeLibraryPrefix } = await import(configPath);
const LIBRARIES = ICON_LIBRARIES;
const SCANNABLE_PREFIXES = new Set(SCANNABLE_PREFIXES_ARRAY);
const COMMENT_STRIPPERS = [
  /<!--[\s\S]*?-->/g, // HTML comments
  /\/\*[\s\S]*?\*\//g, // block comments
  /\/\/.*$/gm, // line comments
];
const FILE_EXTENSIONS = new Set(['.ts', '.tsx', '.js', '.jsx', '.astro', '.mdx', '.md', '.json']);
const EXCLUDED_DIRS = new Set(['node_modules', '.git', 'dist', '.vercel', '.astro']);

function buildIconPattern() {
  const prefixes = Array.from(SCANNABLE_PREFIXES).join('|');
  return new RegExp(`['"\`]((?:${prefixes}):[a-z0-9-]+)['"\`]`, 'gi');
}

function stripComments(content) {
  return COMMENT_STRIPPERS.reduce((acc, regex) => acc.replace(regex, ''), content);
}

const aliasToCanonical = new Map(Object.entries(ICON_LIBRARIES).flatMap(([canonical, meta]) => {
  return [[canonical, canonical], ...(meta.aliases || []).map((alias) => [alias, canonical])];
}));

const normalizePrefix = (prefix) => aliasToCanonical.get(prefix) || normalizeLibraryPrefix(prefix);

function normalizeIconId(raw) {
  const [prefix, name] = raw.split(':');
  const normalizedPrefix = normalizePrefix(prefix);
  return `${normalizedPrefix}:${name}`;
}

async function collectFiles(dir) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files = [];

  for (const entry of entries) {
    if (EXCLUDED_DIRS.has(entry.name)) continue;
    const fullPath = path.join(dir, entry.name);

    if (entry.isDirectory()) {
      files.push(...(await collectFiles(fullPath)));
      continue;
    }

    if (FILE_EXTENSIONS.has(path.extname(entry.name))) {
      if (path.resolve(fullPath) === path.resolve(outputFile)) continue; // avoid self-inclusion
      files.push(fullPath);
    }
  }

  return files;
}

async function extractIconsFromFile(filePath, iconPattern) {
  const content = await fs.readFile(filePath, 'utf8');
  const cleaned = stripComments(content);
  const matches = new Set();

  for (const match of cleaned.matchAll(iconPattern)) {
    const raw = match[1];
    const iconId = normalizeIconId(raw);
    matches.add(iconId);
  }

  return matches;
}

function buildImports(iconIds) {
  const importsByPackage = new Map();

  for (const iconId of iconIds) {
    const [prefix, name] = iconId.split(':');
    const library = LIBRARIES[prefix];
    if (!library) continue;

    const componentName = `${library.componentPrefix}${toPascalCase(name)}`;
    const pkg = library.package;
    if (!importsByPackage.has(pkg)) importsByPackage.set(pkg, new Set());
    importsByPackage.get(pkg).add(componentName);
  }

  return importsByPackage;
}

function renderFile(importsByPackage, iconIds) {
  const header = `// This file is auto-generated by src/integrations/icons/utils/generate-icon-map.mjs.\n// Do not edit manually. Run \"npm run generate:icons\" (or node src/integrations/icons/utils/generate-icon-map.mjs) to regenerate.\n\n`;
  const iconTypeImport = `import type { IconType } from 'react-icons';\n`;
  const importLines = Array.from(importsByPackage.entries())
    .map(([pkg, components]) => `import { ${Array.from(components).sort().join(', ')} } from '${pkg}';`)
    .join('\n');

  const iconEntries = Array.from(iconIds)
    .sort()
    .map((iconId) => {
      const [prefix, name] = iconId.split(':');
      const { componentPrefix } = LIBRARIES[prefix];
      const componentName = `${componentPrefix}${toPascalCase(name)}`;
      return `  '${iconId}': ${componentName},`;
    })
    .join('\n');

  return `${header}${iconTypeImport}${importLines}\n\nexport const iconMap = {\n${iconEntries}\n} satisfies Record<string, IconType>;\n\nexport type IconKey = keyof typeof iconMap;\n`;
}

async function main() {
  const iconPattern = buildIconPattern();
  const searchRoots = [path.join(projectRoot, 'src'), path.join(projectRoot, 'content')];
  const iconIds = new Set();

  for (const root of searchRoots) {
    try {
      const files = await collectFiles(root);
      for (const file of files) {
        const matches = await extractIconsFromFile(file, iconPattern);
        matches.forEach((id) => iconIds.add(id));
      }
    } catch (err) {
      if (err.code !== 'ENOENT') {
        console.error(`Error scanning ${root}:`, err);
      }
    }
  }

  if (iconIds.size === 0) {
    console.warn('No icons found. iconMap.generated.ts will be empty.');
  }

  const importsByPackage = buildImports(iconIds);
  const fileContent = renderFile(importsByPackage, iconIds);
  await fs.mkdir(path.dirname(outputFile), { recursive: true });
  await fs.writeFile(outputFile, fileContent);
  console.log(`Generated ${outputFile} with ${iconIds.size} icon(s).`);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
